[
  {
    "objectID": "reference/server.LogRecordStreamHandler.html",
    "href": "reference/server.LogRecordStreamHandler.html",
    "title": "server.LogRecordStreamHandler",
    "section": "",
    "text": "logging.server.LogRecordStreamHandler()\nHandler for a streaming logging request.\nThis basically logs the record using whatever logging policy is configured locally.\n\n\n\n\n\nName\nDescription\n\n\n\n\nhandle\nHandle multiple requests - each expected to be a 4-byte length,\n\n\n\n\n\nlogging.server.LogRecordStreamHandler.handle()\nHandle multiple requests - each expected to be a 4-byte length, followed by the LogRecord in pickle format. Logs the record according to whatever policy is configured locally.",
    "crumbs": [
      "Home",
      "Reference",
      "server.LogRecordStreamHandler"
    ]
  },
  {
    "objectID": "reference/server.LogRecordStreamHandler.html#methods",
    "href": "reference/server.LogRecordStreamHandler.html#methods",
    "title": "server.LogRecordStreamHandler",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhandle\nHandle multiple requests - each expected to be a 4-byte length,\n\n\n\n\n\nlogging.server.LogRecordStreamHandler.handle()\nHandle multiple requests - each expected to be a 4-byte length, followed by the LogRecord in pickle format. Logs the record according to whatever policy is configured locally.",
    "crumbs": [
      "Home",
      "Reference",
      "server.LogRecordStreamHandler"
    ]
  },
  {
    "objectID": "reference/event_loop.EventLoop.html",
    "href": "reference/event_loop.EventLoop.html",
    "title": "event_loop.EventLoop",
    "section": "",
    "text": "general.event_loop.EventLoop(self, dt_s, stop_event=Event(), ctx=None)\n\n\n\n\n\nName\nDescription\n\n\n\n\nvalidate_callback\nCheck that every callback accepts at least a kwarg with ‘ctx’\n\n\n\n\n\ngeneral.event_loop.EventLoop.validate_callback(cb)\nCheck that every callback accepts at least a kwarg with ‘ctx’",
    "crumbs": [
      "Home",
      "Reference",
      "event_loop.EventLoop"
    ]
  },
  {
    "objectID": "reference/event_loop.EventLoop.html#methods",
    "href": "reference/event_loop.EventLoop.html#methods",
    "title": "event_loop.EventLoop",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nvalidate_callback\nCheck that every callback accepts at least a kwarg with ‘ctx’\n\n\n\n\n\ngeneral.event_loop.EventLoop.validate_callback(cb)\nCheck that every callback accepts at least a kwarg with ‘ctx’",
    "crumbs": [
      "Home",
      "Reference",
      "event_loop.EventLoop"
    ]
  },
  {
    "objectID": "reference/get_streams_names.html",
    "href": "reference/get_streams_names.html",
    "title": "get_streams_names",
    "section": "",
    "text": "stream_watcher.lsl_stream_watcher.get_streams_names()\nGet a list of all available lsl stream names.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nstreams\nlist[str]\nnames of all available LSL streams",
    "crumbs": [
      "Home",
      "Reference",
      "get_streams_names"
    ]
  },
  {
    "objectID": "reference/get_streams_names.html#returns",
    "href": "reference/get_streams_names.html#returns",
    "title": "get_streams_names",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nstreams\nlist[str]\nnames of all available LSL streams",
    "crumbs": [
      "Home",
      "Reference",
      "get_streams_names"
    ]
  },
  {
    "objectID": "reference/time.sleep_s.html",
    "href": "reference/time.sleep_s.html",
    "title": "time.sleep_s",
    "section": "",
    "text": "general.time.sleep_s(s, partial_sleep_threshold=0.0005, nsteps=30)\nSleep for a specified duration with partial sleep optimization.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ns\nfloat\nThe total duration to sleep in seconds.\nrequired\n\n\npartial_sleep_threshold\nfloat\nThe threshold duration above which partial sleep optimization is applied, by default 0.0005. I.e., only for durations s above the threshold, the optimization is applied.\n0.0005\n\n\nnsteps\nint\nThe number of steps for partial sleep, by default 30. Empirical testing showed very good accuracy for 30. If you want to optimize for CPU load, reduce to nsteps &gt; 4.\n30",
    "crumbs": [
      "Home",
      "Reference",
      "time.sleep_s"
    ]
  },
  {
    "objectID": "reference/time.sleep_s.html#parameters",
    "href": "reference/time.sleep_s.html#parameters",
    "title": "time.sleep_s",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ns\nfloat\nThe total duration to sleep in seconds.\nrequired\n\n\npartial_sleep_threshold\nfloat\nThe threshold duration above which partial sleep optimization is applied, by default 0.0005. I.e., only for durations s above the threshold, the optimization is applied.\n0.0005\n\n\nnsteps\nint\nThe number of steps for partial sleep, by default 30. Empirical testing showed very good accuracy for 30. If you want to optimize for CPU load, reduce to nsteps &gt; 4.\n30",
    "crumbs": [
      "Home",
      "Reference",
      "time.sleep_s"
    ]
  },
  {
    "objectID": "reference/server.modify_root_logger.html",
    "href": "reference/server.modify_root_logger.html",
    "title": "server.modify_root_logger",
    "section": "",
    "text": "server.modify_root_logger\nlogging.server.modify_root_logger(logfile)",
    "crumbs": [
      "Home",
      "Reference",
      "server.modify_root_logger"
    ]
  },
  {
    "objectID": "reference/time.full_speed.html",
    "href": "reference/time.full_speed.html",
    "title": "time.full_speed",
    "section": "",
    "text": "time.full_speed\ngeneral.time.full_speed(s, start)",
    "crumbs": [
      "Home",
      "Reference",
      "time.full_speed"
    ]
  },
  {
    "objectID": "reference/DefaultServer.html",
    "href": "reference/DefaultServer.html",
    "title": "DefaultServer",
    "section": "",
    "text": "default_server.server.DefaultServer(\n    self,\n    port=8080,\n    ip='0.0.0.0',\n    nlisten=10,\n    name='default_server',\n    thread_stopper=stop_thread,\n    proc_stopper=stop_process,\n    msg_interpreter=interpret_msg,\n    pcommand_map=dict(),\n    current_conn=None,\n    server_socket=None,\n    threads=dict(),\n    processes=dict(),\n    is_listening=False,\n    logger=get_logger(__name__),\n)\nThe default server which is being used and modified by pther dareplane projects\n\n\n\n\n\nName\nDescription\n\n\n\n\ndefault_msg_interpretation\nThis contains the default interpretation\n\n\nhandle_msg\ninterpret the message\n\n\nmsg_interpretation\nInterpret the message and perform book keeping if necessary\n\n\nshutdown\nShutdown the server and close all connections\n\n\n\n\n\ndefault_server.server.DefaultServer.default_msg_interpretation(msg)\nThis contains the default interpretation\n\n\n\ndefault_server.server.DefaultServer.handle_msg(msg)\ninterpret the message\n\n\n\ndefault_server.server.DefaultServer.msg_interpretation(msg)\nInterpret the message and perform book keeping if necessary\n\n\n\ndefault_server.server.DefaultServer.shutdown()\nShutdown the server and close all connections",
    "crumbs": [
      "Home",
      "Reference",
      "DefaultServer"
    ]
  },
  {
    "objectID": "reference/DefaultServer.html#methods",
    "href": "reference/DefaultServer.html#methods",
    "title": "DefaultServer",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndefault_msg_interpretation\nThis contains the default interpretation\n\n\nhandle_msg\ninterpret the message\n\n\nmsg_interpretation\nInterpret the message and perform book keeping if necessary\n\n\nshutdown\nShutdown the server and close all connections\n\n\n\n\n\ndefault_server.server.DefaultServer.default_msg_interpretation(msg)\nThis contains the default interpretation\n\n\n\ndefault_server.server.DefaultServer.handle_msg(msg)\ninterpret the message\n\n\n\ndefault_server.server.DefaultServer.msg_interpretation(msg)\nInterpret the message and perform book keeping if necessary\n\n\n\ndefault_server.server.DefaultServer.shutdown()\nShutdown the server and close all connections",
    "crumbs": [
      "Home",
      "Reference",
      "DefaultServer"
    ]
  },
  {
    "objectID": "examples/hello_world/hello_world.html",
    "href": "examples/hello_world/hello_world.html",
    "title": "Hello World for Dareplane with python modules",
    "section": "",
    "text": "This example will guide you through the process of creating a simple motor imagery task as a Dareplane module and then hook it up with a mock-up data streamer as well as LSL recording. Completing this example you will have a data source (mockup only), a paradigm providing visual queues and markers and finally recording of markers and streaming data with LSL into an *.xdf file.\n\n\nInstall the dareplane-utils to make use of the default TCP server. E.g. via pip install dareplane-utils.\n\n\n\nFirst, lets decide to call the module dp-mi-paradigm. The prefix of dp- for Dareplane is arbitrary and you can of course choose not to use it.\n\n\nTo start, get the dp-strawman-module and read the README.md therein carefully. After that you should know how to build upon the strawman. So lets rename the relevant folders. The content of our new module folder ./dp-mi-paradigm should then look like this:\n├── LICENSE\n├── README.md\n├── api\n│   └── server.py\n├── configs\n├── mi_paradigm\n│   ├── main.py\n│   └── utils\n│       └── logging.py\n└── tests\n\n\n\nFor our paradigm we decide to show simple instructions for motor imagination of left (L) and right ( R) hand movement by displaying letters ‘L’ and ‘R’ as well as a fixation cross ‘+’ using psychopy. In addition, we want to send markers to an LSL stream capturing when a direction is shown.\nSo our ./mi_paradigm/main.py could look like this.\n```python ./mi_paradigm/main.py\nfrom fire import Fire import time import random import pylsl from psychopy.visual import TextStim, Window\nfrom mi_paradigm.utils.logging import logger\nlogger.setLevel(10)\nBG_COLOR = (0, 0, 0) TEXT_COLOR = (1, 0, 0)"
  },
  {
    "objectID": "examples/hello_world/hello_world.html#get-the-dareplane-pyutils",
    "href": "examples/hello_world/hello_world.html#get-the-dareplane-pyutils",
    "title": "Hello World for Dareplane with python modules",
    "section": "",
    "text": "Install the dareplane-utils to make use of the default TCP server. E.g. via pip install dareplane-utils."
  },
  {
    "objectID": "examples/hello_world/hello_world.html#building-the-paradigm-module",
    "href": "examples/hello_world/hello_world.html#building-the-paradigm-module",
    "title": "Hello World for Dareplane with python modules",
    "section": "",
    "text": "First, lets decide to call the module dp-mi-paradigm. The prefix of dp- for Dareplane is arbitrary and you can of course choose not to use it.\n\n\nTo start, get the dp-strawman-module and read the README.md therein carefully. After that you should know how to build upon the strawman. So lets rename the relevant folders. The content of our new module folder ./dp-mi-paradigm should then look like this:\n├── LICENSE\n├── README.md\n├── api\n│   └── server.py\n├── configs\n├── mi_paradigm\n│   ├── main.py\n│   └── utils\n│       └── logging.py\n└── tests\n\n\n\nFor our paradigm we decide to show simple instructions for motor imagination of left (L) and right ( R) hand movement by displaying letters ‘L’ and ‘R’ as well as a fixation cross ‘+’ using psychopy. In addition, we want to send markers to an LSL stream capturing when a direction is shown.\nSo our ./mi_paradigm/main.py could look like this.\n```python ./mi_paradigm/main.py\nfrom fire import Fire import time import random import pylsl from psychopy.visual import TextStim, Window\nfrom mi_paradigm.utils.logging import logger\nlogger.setLevel(10)\nBG_COLOR = (0, 0, 0) TEXT_COLOR = (1, 0, 0)"
  },
  {
    "objectID": "examples/hello_world/hello_world.html#running-your-module-from-the-control-room",
    "href": "examples/hello_world/hello_world.html#running-your-module-from-the-control-room",
    "title": "Hello World for Dareplane with python modules",
    "section": "Running your module from the control room",
    "text": "Running your module from the control room\nIt is now time to integrate the dp-mi-paradigm with other modules. This is done using the dp-control-room. If you do not yet have it, clone it from git and place it e.g. in the parent directory of pd-mi-paradigm. So that you have the pd-mi-paradigm and pd-control-room paradigm in the same folder. Make sure to have all dependencies of the control room installed. Try pip install -r requirements.txt from within the pd-control-room folder.\nThen move into the dp-control-room directory and create a config at ./configs/mi_experiment.toml with the following content:\n```toml ./configs/mi_experiment.toml [python] modules_root = ‘../’"
  },
  {
    "objectID": "docs/index.html",
    "href": "docs/index.html",
    "title": "Documentation",
    "section": "",
    "text": "The documentation mainly covers the dareplane-utils Python package. Please refere to the individual modules and their README.md for further details on individual modules."
  },
  {
    "objectID": "docs/index.html#dareplane_utils",
    "href": "docs/index.html#dareplane_utils",
    "title": "Documentation",
    "section": "dareplane_utils",
    "text": "dareplane_utils\nUtility functions for Python regarding common components which can be usefull for multiple Dareplane modules.\n\nServer\nThe server components can be used from dareplane_utils.default_server.server\n\n\n\nDefaultServer\nThe default server which is being used and modified by pther dareplane\n\n\n\n\n\nLogging\nLogging components which add a TCP handler to a logger derived from Python’s standard logging.Logger. This allows to the dp-control-room to create a single consolidated log-file.\n\n\n\nlogger.get_logger\nGet a configured logger.\n\n\nserver.LogRecordStreamHandler\nHandler for a streaming logging request.\n\n\nserver.LogRecordSocketReceiver\nSimple TCP socket-based logging receiver suitable for testing.\n\n\nserver.modify_root_logger\n\n\n\n\n\n\nStreaming data\nDareplane relies mostly on the lab streaming layer (LSL) for streaming data. A central element of the dareplane-utils is the StreamWatcher which is a ring buffer to read from streams. Currently we only have a StreamWatcher for LSL implemented, using pylsl and inlets defined therein.\n\n\n\nStreamWatcher\n\n\n\nget_streams_names\nGet a list of all available lsl stream names.\n\n\npylsl_xmlelement_to_dict\nThe pylsl XMLElement is hard to investigate -&gt; cast to a dict for\n\n\nget_channel_names\n\n\n\n\n\n\nGeneral\nGeneral utility functions and classes\n\n\n\nringbuffer.RingBuffer\n\n\n\ntime.sleep_s\nSleep for a specified duration with partial sleep optimization.\n\n\ntime.partial_sleep\nSleep for 90% of s or up to 30ms to the end, whatever is longer\n\n\ntime.full_speed\n\n\n\nevent_loop.EventLoop"
  },
  {
    "objectID": "docs/documentation_setup.html",
    "href": "docs/documentation_setup.html",
    "title": "Documentation setup",
    "section": "",
    "text": "The documentation for Dareplane is generated with Quarto and quartodoc. The later is used to automatically generate API documentation for python modules. Quarto uses a central _quarto.yml file to configure the documentation.\n\n\n\nCurrently the Home section is sourced from the main.qmd file as directly including the README.md did not work. As I could not get the logo to work properly (neither could I just ignore). The basic idea was from the quarto docs."
  },
  {
    "objectID": "docs/documentation_setup.html#todo",
    "href": "docs/documentation_setup.html#todo",
    "title": "Documentation setup",
    "section": "",
    "text": "Currently the Home section is sourced from the main.qmd file as directly including the README.md did not work. As I could not get the logo to work properly (neither could I just ignore). The basic idea was from the quarto docs."
  },
  {
    "objectID": "docs/main.html",
    "href": "docs/main.html",
    "title": "Dareplane",
    "section": "",
    "text": "Dareplane is a modular and broad technology agnostic open source software platform for brain-computer interface research. LSL is used for data communication and TCP sockets for module communication. The platform is designed to be minimalistic and to allow for easy development of custom modules, with minimal overhead of integrating existing code.\nCaveat: The platform is in an early alpha stage and is developed by a small group of developers. Although core functionality is implemented and the platform has been used in &gt;20 experimental sessions including simultaneous recording of EEG, ECoG, LFP and other signal modalities, please be aware that bugs are still likely and thorough testing of every setup is required.\nThe target users are developers of experimental setups who require customized software components, or who just want to have full control over the functionality of data I/O, algorithmic processing, and/or on stimulation and feedback. For this user group, Dareplane aims to provide a minimalistic framework which allows to develop and integrate bespoke modules in a simple way. It is a mind-child of the https://suckless.org/ philosophy and tries to adapt it in a pragmatic manner with research in the focus.\nIf you are looking for a setup that is more or less ready to use out of the box, you will be better of using a more mature framework which is oriented towards more plug-and-play components. In any case it is good to have a look at the other frameworks section."
  },
  {
    "objectID": "docs/main.html#the-design-philosophy-of-dareplane",
    "href": "docs/main.html#the-design-philosophy-of-dareplane",
    "title": "Dareplane",
    "section": "The design philosophy of Dareplane",
    "text": "The design philosophy of Dareplane\nThe basic idea of the Dareplane platform is to provide a modular approach for software components used for research of neuro-technology. The design goals are:\n\nto provide reusable single purpose modules which can be integrated into a larger system;\nto be technology agnostic, so that modules can be used with different hardware and developed in different languages;\nto be minimalistic in terms of constraints and required overhead for integrating existing software into the platform.\n\nThe implications of these design goals are:\n\nA common channel of communication between modules is required, which should work with a wide range of hardware and software. For Dareplane this is solved by using TCP sockets for module communication. For data transfer, the awesome LSL framework is used.\nA common protocol for communication is required, which Dareplane implements as string communication using what is referred to as primary commands. This is an arbitray string following by a pipe delimiter and potentially a json payload. Imagine a module for recording EEG data from a single data source. On a high level, a command you would want to use is: STARTRECORDING|{\"path\":\"./mydatafolder/\", \"file\": \"myrecoding.xdf\"}."
  },
  {
    "objectID": "docs/main.html#overview-of-the-dareplane-projects-and-individual-modules",
    "href": "docs/main.html#overview-of-the-dareplane-projects-and-individual-modules",
    "title": "Dareplane",
    "section": "Overview of the Dareplane projects and individual modules",
    "text": "Overview of the Dareplane projects and individual modules\n\n\n\nLink\nDescription\n\n\n\n\ndp-strawmam-module\na strawman repository as starting point for developing your modules\n\n\ndp-control-room\nthe central module which combines individual modules to a system\n\n\ndp-lsl-recording\nmodule for interacting with the LSL LabRecorder\n\n\ndp-mockup-streamer\nmodule for creating mock-up streams from files or generating random data\n\n\ndp-copydraw\nmodule to run the CopyDraw - Castano et al. 2019 paradigm\n\n\ndp-multiband-regression\nmodule to perform a multiband regression based on a multichannel data stream\n\n\ndp-bollinger-control\na Bollinger Band control module\n\n\ndp-ao-communicatio\na C++ module interacting with the Alpha Omega’s API\n\n\ndp-ao-stimulator\npython module to trigger stimulation via dp-ao-communication\n\n\ndp-arduino-stimulator\nmodule to use an Arduino as a mock-up of a neuro-stimulator\n\n\ndp-picoscope-streamer\nmodule to stream data from a Picoscope to LSL\n\n\ndp-passthrough\na simple passthrough Dareplane module for performance testing\n\n\ndp-threshold-controller\na threshold control module with grace periods\n\n\ndp-cortec-bic\nmodule to interact with the API of the CorTec BrainInterchange\n\n\ndp-cvep-speller\na c-VEP speller paradigm module\n\n\ndp-cvep-decoder\ndecoding module for a c-VEP speller, using rCCA"
  },
  {
    "objectID": "docs/main.html#getting-started",
    "href": "docs/main.html#getting-started",
    "title": "Dareplane",
    "section": "Getting started",
    "text": "Getting started\nA good starting point is the cVEP experiment, which contains a setup script that downloads and configures a cVEP speller, outlining how modules need to be configured for interaction.\n\nFor python modules / development\nIf you are building your modules in python, or using the existing python modules, the dareplane-utils python module will provide some core functionality which most modules will need.\npip install dareplane-utils\nThe module provides basic functionality around TCP servers, logging, and collecting data from LSL streams.\n\nControl Room module\nThe control room module is the central piece for composition of modules to a full setup. Modules you need in your experiment are added within a setup configuration file (see ./examples and the documentation in the control room)"
  },
  {
    "objectID": "docs/main.html#getting-started-1",
    "href": "docs/main.html#getting-started-1",
    "title": "Dareplane",
    "section": "Getting started",
    "text": "Getting started\nRefer to the ./examples documents to so see a minimalistic setup and guidance on how to develop your own modules."
  },
  {
    "objectID": "docs/main.html#other-frameworks",
    "href": "docs/main.html#other-frameworks",
    "title": "Dareplane",
    "section": "Other frameworks",
    "text": "Other frameworks\nThis is a non-exhaustive list of other frameworks which might be more suitable depending on your needs:\n\nBCI2000\nMedusabci\ntimeflux"
  },
  {
    "objectID": "examples/examples.html",
    "href": "examples/examples.html",
    "title": "Examples",
    "section": "",
    "text": "Examples\nSome Dareplane example implementations\nMANUALLY list here"
  },
  {
    "objectID": "reference/logger.get_logger.html",
    "href": "reference/logger.get_logger.html",
    "title": "logger.get_logger",
    "section": "",
    "text": "logging.logger.get_logger(\n    name,\n    add_console_handler=False,\n    colors=colors,\n    no_socket_handler=False,\n)\nGet a configured logger.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe name of the logger.\nrequired\n\n\nadd_console_handler\nbool\nIf True, add a console handler to the logger (default is False).\nFalse\n\n\ncolors\ndict\nA dictionary of colors for log levels (default is colors).\ncolors\n\n\nno_socket_handler\nbool\nIf True, opt out of adding a socket handler for TCP streaming (default is False).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlogging.Logger\nThe configured logger.",
    "crumbs": [
      "Home",
      "Reference",
      "logger.get_logger"
    ]
  },
  {
    "objectID": "reference/logger.get_logger.html#parameters",
    "href": "reference/logger.get_logger.html#parameters",
    "title": "logger.get_logger",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nThe name of the logger.\nrequired\n\n\nadd_console_handler\nbool\nIf True, add a console handler to the logger (default is False).\nFalse\n\n\ncolors\ndict\nA dictionary of colors for log levels (default is colors).\ncolors\n\n\nno_socket_handler\nbool\nIf True, opt out of adding a socket handler for TCP streaming (default is False).\nFalse",
    "crumbs": [
      "Home",
      "Reference",
      "logger.get_logger"
    ]
  },
  {
    "objectID": "reference/logger.get_logger.html#returns",
    "href": "reference/logger.get_logger.html#returns",
    "title": "logger.get_logger",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nlogging.Logger\nThe configured logger.",
    "crumbs": [
      "Home",
      "Reference",
      "logger.get_logger"
    ]
  },
  {
    "objectID": "reference/get_channel_names.html",
    "href": "reference/get_channel_names.html",
    "title": "get_channel_names",
    "section": "",
    "text": "get_channel_names\nstream_watcher.lsl_stream_watcher.get_channel_names(inf)",
    "crumbs": [
      "Home",
      "Reference",
      "get_channel_names"
    ]
  },
  {
    "objectID": "reference/ringbuffer.RingBuffer.html",
    "href": "reference/ringbuffer.RingBuffer.html",
    "title": "ringbuffer.RingBuffer",
    "section": "",
    "text": "general.ringbuffer.RingBuffer(self, shape, dtype=np.float32)\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nbuffer\nnp.ndarray\nthe data buffer\n\n\nbuffer_t\nnp.ndarray\nthe time buffer\n\n\nlast_t\nfloat\nlatest time stamp\n\n\ncurr_i\nint\nindex of the latest data point int the buffer\n\n\nlogger\nlogging.Logger\nthe logger used for warnings and debug messages\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nshape\ntuple[int, int, …]\nshape of the buffer needs to be at least 2D (n_samples, n_features), arbitrary further dimensions can be added\nrequired\n\n\ndtype\ntype\na numpy data type for the buffer\nnp.float32\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_continuous_buffer\nSlice samples should not be necessary &gt;&gt;&gt; as we add continuously\n\n\nget_insert_slices\nGet slices mapping data from the samples to the buffer\n\n\n\n\n\ngeneral.ringbuffer.RingBuffer.add_continuous_buffer(\n    slice_buffer,\n    samples,\n    times,\n)\nSlice samples should not be necessary &gt;&gt;&gt; as we add continuously + slice selection from lists is slow\n\n\n\ngeneral.ringbuffer.RingBuffer.get_insert_slices(len_samples)\nGet slices mapping data from the samples to the buffer\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlen_samples\nint\nnumber of samples to add\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple[list[slice], list[slice], int]",
    "crumbs": [
      "Home",
      "Reference",
      "ringbuffer.RingBuffer"
    ]
  },
  {
    "objectID": "reference/ringbuffer.RingBuffer.html#attributes",
    "href": "reference/ringbuffer.RingBuffer.html#attributes",
    "title": "ringbuffer.RingBuffer",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nbuffer\nnp.ndarray\nthe data buffer\n\n\nbuffer_t\nnp.ndarray\nthe time buffer\n\n\nlast_t\nfloat\nlatest time stamp\n\n\ncurr_i\nint\nindex of the latest data point int the buffer\n\n\nlogger\nlogging.Logger\nthe logger used for warnings and debug messages",
    "crumbs": [
      "Home",
      "Reference",
      "ringbuffer.RingBuffer"
    ]
  },
  {
    "objectID": "reference/ringbuffer.RingBuffer.html#parameters",
    "href": "reference/ringbuffer.RingBuffer.html#parameters",
    "title": "ringbuffer.RingBuffer",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nshape\ntuple[int, int, …]\nshape of the buffer needs to be at least 2D (n_samples, n_features), arbitrary further dimensions can be added\nrequired\n\n\ndtype\ntype\na numpy data type for the buffer\nnp.float32",
    "crumbs": [
      "Home",
      "Reference",
      "ringbuffer.RingBuffer"
    ]
  },
  {
    "objectID": "reference/ringbuffer.RingBuffer.html#methods",
    "href": "reference/ringbuffer.RingBuffer.html#methods",
    "title": "ringbuffer.RingBuffer",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_continuous_buffer\nSlice samples should not be necessary &gt;&gt;&gt; as we add continuously\n\n\nget_insert_slices\nGet slices mapping data from the samples to the buffer\n\n\n\n\n\ngeneral.ringbuffer.RingBuffer.add_continuous_buffer(\n    slice_buffer,\n    samples,\n    times,\n)\nSlice samples should not be necessary &gt;&gt;&gt; as we add continuously + slice selection from lists is slow\n\n\n\ngeneral.ringbuffer.RingBuffer.get_insert_slices(len_samples)\nGet slices mapping data from the samples to the buffer\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlen_samples\nint\nnumber of samples to add\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple[list[slice], list[slice], int]",
    "crumbs": [
      "Home",
      "Reference",
      "ringbuffer.RingBuffer"
    ]
  },
  {
    "objectID": "reference/pylsl_xmlelement_to_dict.html",
    "href": "reference/pylsl_xmlelement_to_dict.html",
    "title": "pylsl_xmlelement_to_dict",
    "section": "",
    "text": "pylsl_xmlelement_to_dict\nstream_watcher.lsl_stream_watcher.pylsl_xmlelement_to_dict(inf)\nThe pylsl XMLElement is hard to investigate -&gt; cast to a dict for simplicity",
    "crumbs": [
      "Home",
      "Reference",
      "pylsl_xmlelement_to_dict"
    ]
  },
  {
    "objectID": "reference/server.LogRecordSocketReceiver.html",
    "href": "reference/server.LogRecordSocketReceiver.html",
    "title": "server.LogRecordSocketReceiver",
    "section": "",
    "text": "server.LogRecordSocketReceiver\nlogging.server.LogRecordSocketReceiver(\n    self,\n    host='localhost',\n    port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,\n    handler=LogRecordStreamHandler,\n    logfile=Path('default_socket.log'),\n)\nSimple TCP socket-based logging receiver suitable for testing.",
    "crumbs": [
      "Home",
      "Reference",
      "server.LogRecordSocketReceiver"
    ]
  },
  {
    "objectID": "reference/time.partial_sleep.html",
    "href": "reference/time.partial_sleep.html",
    "title": "time.partial_sleep",
    "section": "",
    "text": "time.partial_sleep\ngeneral.time.partial_sleep(s, start, nsteps=30)\nSleep for 90% of s or up to 30ms to the end, whatever is longer",
    "crumbs": [
      "Home",
      "Reference",
      "time.partial_sleep"
    ]
  },
  {
    "objectID": "reference/StreamWatcher.html",
    "href": "reference/StreamWatcher.html",
    "title": "StreamWatcher",
    "section": "",
    "text": "stream_watcher.lsl_stream_watcher.StreamWatcher(\n    self,\n    name='',\n    buffer_size_s=2,\n    logger=logger,\n)\n\n\n\n\n\nName\nDescription\n\n\n\n\nconnect_to_stream\nEither use the self.name or a provided identifier dict to hook up\n\n\ndisconnect\nDestroying the inlet will disconnect -&gt; see pylsl.pylsl.py\n\n\nupdate_numeric\nLook for new data and update the buffer\n\n\n\n\n\nstream_watcher.lsl_stream_watcher.StreamWatcher.connect_to_stream(\n    identifier=None,\n)\nEither use the self.name or a provided identifier dict to hook up with an LSL stream, they should coincide\n\n\n\nstream_watcher.lsl_stream_watcher.StreamWatcher.disconnect()\nDestroying the inlet will disconnect -&gt; see pylsl.pylsl.py\n\n\n\nstream_watcher.lsl_stream_watcher.StreamWatcher.update_numeric()\nLook for new data and update the buffer",
    "crumbs": [
      "Home",
      "Reference",
      "StreamWatcher"
    ]
  },
  {
    "objectID": "reference/StreamWatcher.html#methods",
    "href": "reference/StreamWatcher.html#methods",
    "title": "StreamWatcher",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconnect_to_stream\nEither use the self.name or a provided identifier dict to hook up\n\n\ndisconnect\nDestroying the inlet will disconnect -&gt; see pylsl.pylsl.py\n\n\nupdate_numeric\nLook for new data and update the buffer\n\n\n\n\n\nstream_watcher.lsl_stream_watcher.StreamWatcher.connect_to_stream(\n    identifier=None,\n)\nEither use the self.name or a provided identifier dict to hook up with an LSL stream, they should coincide\n\n\n\nstream_watcher.lsl_stream_watcher.StreamWatcher.disconnect()\nDestroying the inlet will disconnect -&gt; see pylsl.pylsl.py\n\n\n\nstream_watcher.lsl_stream_watcher.StreamWatcher.update_numeric()\nLook for new data and update the buffer",
    "crumbs": [
      "Home",
      "Reference",
      "StreamWatcher"
    ]
  }
]